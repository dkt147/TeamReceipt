import request from 'supertest';
import bcrypt from 'bcrypt';
import { PrismaClient } from '@prisma/client';
import createServer from '../src/index.js';
import AuthService from '../src/Services/AuthenticationService.js';
import { generateAccessToken, generateRefreshToken } from '../src/Utils/GenerateJWTToken.js';
const prisma = new PrismaClient();

describe("generate the accessToken from refreshToken", () => {
  const app = createServer();
  let user;
  let userExists;
  let refreshToken;
  let accessToken;
  let authService = new AuthService();

  beforeAll(async () => {
    user = {
      name: "User1",
      email: "user1@email.com",
      password: "password123"
    };

    await prisma.users.create({
      data: {
        name: user.name,
        email: user.email,
        username: `user${Math.floor(1000 + Math.random() * 9000)}`,
        password: bcrypt.hashSync(user.password, 10),
      },
    });

    userExists = await prisma.users.findFirst({
      where: {
        email: user.email,
      }
    });

    refreshToken = generateRefreshToken({
      id: userExists.id,
      name: userExists.name,
      email: userExists.email,
      username: userExists.username
    });

    accessToken = generateRefreshToken({
      id: userExists.id,
      name: userExists.name,
      email: userExists.email,
      username: userExists.username
    });
  });

  afterAll(async () => {
    await prisma.users.deleteMany({
      where: {
        email: user.email
      }
    });
    await prisma.$disconnect();
  });

  test("valid password", () => {
    const passwordMatch = bcrypt.compareSync(
      user.password,
      userExists.password
    );

    expect(passwordMatch).toBeTruthy();
  });

  test("valid accessToken generated by refreshToken", () => {
    expect(refreshToken).not.toBeNull();
    expect(refreshToken).toBeDefined();
  });

  test("sign function returns tokens", async () => {
    const response = await authService.signin({ email: user.email, password: user.password });

    expect(response).toHaveProperty('accessToken');
    expect(response).toHaveProperty('refreshToken');
  });

  test("Post signup: should return 200", async () => {
    const newUser = {
      name: "User2",
      email: "user2@email.com",
      password: "password123"
    };

    const response = await request(app)
      .post("/auth/signup")
      .set("content-type", "application/json")
      .send({
        name: newUser.name,
        email: newUser.email,
        password: newUser.password
      });

    expect(response.body.statusCode).toBe(201);
    expect(response.body.message).toEqual("User created successfully");
    expect(response.body.success).toBeTruthy();

    await prisma.users.deleteMany({
      where: {
        email: newUser.email
      }
    });
  });

  test("Post signup: should return 404 if the user with the same email exist", async () => {
    const response = await request(app)
      .post("/auth/signup")
      .set("content-type", "application/json")
      .send({
        name: user.name,
        email: user.email,
        password: user.password
      });

    expect(response.body.statusCode).toBe(404);
    expect(response.body.status).toEqual("User already exists");
  });

  test("Post signin endpoint sets httpOnly cookies", async () => {
    const response = await request(app)
      .post("/auth/signin")
      .set("content-type", "application/json")
      .send({
        email: user.email,
        password: user.password
      });

    expect(response.status).toBe(200);
    expect(response.body).toHaveProperty('accessToken');
    expect(response.body).toHaveProperty('refreshToken');

    const cookies = response.headers['set-cookie'];
    expect(cookies).toBeDefined();
    expect(cookies.length).toBeGreaterThan(0);

    cookies.forEach(cookie => {
      expect(cookie).toEqual(expect.stringContaining('HttpOnly'));
    });
  });

  test("Post signin: does not exist", async () => {
    const response = await request(app)
      .post("/auth/signin")
      .set("content-type", "application/json")
      .send({
        email: user.email,
        password: user.password
      });

    expect(response.status).toBe(200);
    expect(response.body).toHaveProperty('accessToken');
    expect(response.body).toHaveProperty('refreshToken');

    const cookies = response.headers['set-cookie'];
    expect(cookies).toBeDefined();
    expect(cookies.length).toBeGreaterThan(0);

    cookies.forEach(cookie => {
      expect(cookie).toEqual(expect.stringContaining('HttpOnly'));
    });
  });

  test("Post refresh-token", async () => {
    const response = await request(app)
      .post("/auth/refresh-token")
      .set("content-type", "application/json")
      .set('Cookie', `refreshToken=${refreshToken}; HttpOnly; Secure; SameSite=Strict`);

    const cookies = response.headers['set-cookie'];
    expect(cookies).toBeDefined();
    expect(cookies.length).toBeGreaterThan(0);

    cookies.forEach(cookie => {
      expect(cookie).toEqual(expect.stringContaining('HttpOnly'));
    });
  });
  test("Post refresh-token", async () => {
    const response = await request(app)
      .post("/auth/refresh-token")
      .set("content-type", "application/json");

    const cookies = response.headers['set-cookie'];
    expect(cookies).not.toBeDefined();
    expect(response.body.message).toEqual("Refresh token not provided");
  });


  test("Put passwordRecovery success", async () => {
    const response = await request(app)
      .put("/auth/passwordRecovery")
      .set("content-type", "application/json")
      .send({
        email: user.email,
        password: user.password
      });
    
    expect(response.body.statusCode).toBe(201);
    expect(response.body.message).toEqual('Password reset successfully');
    expect(response.body.success).toBeTruthy();
  });

  test("Put passwordRecovery: does not exist user", async () => {
    const response = await request(app)
      .put("/auth/passwordRecovery")
      .set("content-type", "application/json")
      .send({
        email: 'wrong-email',
        password: user.password
      });
    
    expect(response.body.statusCode).toBe(404);
    expect(response.body.status).toEqual('User Does not exist');
  });
  
  test("Put passwordRecovery: no field", async () => {
    const response = await request(app)
      .put("/auth/passwordRecovery")
      .set("content-type", "application/json")
      .send({
        email: '',
        password: ''
      });
    
    expect(response.body.statusCode).toBe(404);
    expect(response.body.status).toEqual('Invalid data');
  });

  test("Post logout", async () => {
    const response = await request(app)
      .post("/auth/logout")
      .set("content-type", "application/json");

    expect(response.body.message).toEqual("Logout successful");
  });
});